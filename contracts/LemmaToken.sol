//SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol";

import "./Pricer.sol";
import "./StringValidator.sol";
import "./OpenSea.sol";

/// @title The LemmaToken is the Lexiconomy's NFT
/// @author Devin Stein
/// @notice The LemmaToken contract is the core of the Lexiconomy logic.
/// @dev The meat of the ERC721 logic is implemented by OpenZepplin. The minting logic and NFT on-chain data is customized to the Lexiconomy.
contract LemmaToken is
  ERC721,
  ERC721Enumerable,
  ERC721URIStorage,
  Pausable,
  Ownable
{
  using ERC165Checker for address;

  // BEGIN: Generated by OpenZepplin
  constructor() ERC721("The Lexiconomy v2", "LEX") {}

  function pause() public onlyOwner {
    _pause();
  }

  function unpause() public onlyOwner {
    _unpause();
  }

  function _baseURI() internal pure override returns (string memory) {
    // tokenURI concats the baseURI with the token id
    // TODO: return "https://lexiconomy.org/token/";
    return "https://lexiconomy-v2.vercel.app/token/";
  }

  function contractURI() public pure returns (string memory) {
    // TODO: return "https://lexiconomy.org/contract/metadata";
    return "https://lexiconomy-v2.vercel.app/contract/metadata";
  }

  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 tokenId
  ) internal override(ERC721, ERC721Enumerable) whenNotPaused {
    super._beforeTokenTransfer(from, to, tokenId);
  }

  function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
    super._burn(tokenId);
  }

  function tokenURI(uint256 tokenId)
    public
    view
    override(ERC721, ERC721URIStorage)
    returns (string memory)
  {
    return super.tokenURI(tokenId);
  }

  function supportsInterface(bytes4 interfaceId)
    public
    view
    override(ERC721, ERC721Enumerable)
    returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }

  // END: Generated by OpenZepplin

  // BEGIN: Support OpenSea Trading
  address public proxyRegistryAddress;

  function isApprovedForAll(address owner, address operator)
    public
    view
    override
    returns (bool)
  {
    // only execute if proxyRegistryAddress is set
    if (proxyRegistryAddress != address(0)) {
      // Whitelist OpenSea proxy contract for easy trading
      ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);
      if (address(proxyRegistry.proxies(owner)) == operator) {
        return true;
      }
    }

    return super.isApprovedForAll(owner, operator);
  }

  function setProxyRegistryAddress(address _address) public onlyOwner {
    proxyRegistryAddress = _address;
  }

  // END: Support OpenSea Trading

  /// @notice The Invent event is fired whenever a new lemma is invented
  /// @dev The Invent event allows for easy access to the lemma (string) value of newly minted tokens
  event Invent(
    address indexed owner,
    uint256 indexed tokenId,
    string lemma,
    uint256 number
  );

  /// @notice Definition event whenever an owner defines or redefines their lemma
  /// @dev Definition events help maintain the history of definitions for a lemma over time.
  event Definition(
    address indexed owner,
    uint256 indexed tokenId,
    string definition
  );

  /// @notice Example event whenever an owner provides an example for their lemma
  /// @dev Example events help maintain the history of examples for a lemma over time.
  event Example(address indexed owner, uint256 indexed tokenId, string example);

  /// @notice The Lemma struct is the on-chain representation of a lemma
  struct Lemma {
    string lemma;
    string definition;
    string example;
    // number is a monotonically increasing value for every lemma
    uint256 number;
  }

  /// @notice The lemmas mapping maintains all on-chain data for every token
  mapping(uint256 => Lemma) public lemmas;

  bytes4 public constant pricerInterfaceId = type(Pricer).interfaceId;
  Pricer public pricer;

  /// @dev Allows the owner to update the Pricer contract. This allows flexibility on the pricing strategies in the future.
  function setPricer(address _address) public onlyOwner {
    require(
      _address.supportsInterface(pricerInterfaceId),
      "LemmaToken: address does not implement the Pricer interface"
    );

    Pricer candidateContract = Pricer(_address);

    // Set the new contract address
    pricer = candidateContract;
  }

  bytes4 public constant stringValidatorInterfaceId =
    type(StringValidator).interfaceId;
  StringValidator public lemmaValidator;

  /// @dev Allows the owner to update the LemmaValidator contract. This allows flexibility on the pricing strategies in the future
  function setLemmaValidator(address _address) public onlyOwner {
    require(
      _address.supportsInterface(stringValidatorInterfaceId),
      "LemmaToken: address does not implement the StringValidator interface"
    );

    StringValidator candidateContract = StringValidator(_address);

    // Set the new contract address
    lemmaValidator = candidateContract;
  }

  /// @notice mintFee returns the current minting fee
  /// @return The current minting fee
  function mintFee() public view returns (uint256) {
    return pricer.price();
  }

  /// @notice lemmaValid checks if a given lemma string is valid
  /// @param _lemma the string to validate
  /// @return True if the lemma is valid; otherwise, false
  /// @dev Calls the LemmaValidator.valid method
  function lemmaValid(string calldata _lemma) public view returns (bool) {
    return lemmaValidator.valid(_lemma);
  }

  /// @notice Get the token ID for a given string
  /// @param _lemma the string to get a token ID for
  /// @return The ERC721 token ID
  /// @dev Useful for getting the token ID of a lemma client-side
  function getTokenId(string calldata _lemma) public pure returns (uint256) {
    return uint256(keccak256(bytes(_lemma)));
  }

  /// @dev The internal mint function for creating a new token
  function _mint(
    address to,
    uint256 tokenId,
    string calldata _lemma,
    string calldata _definition,
    string calldata _example
  ) internal {
    // _safeMint verifies the tokenId doesn't exist
    _safeMint(to, tokenId);
    uint256 number = totalSupply();
    lemmas[tokenId] = Lemma(_lemma, _definition, _example, number);

    // emit Invent to let us easily query all created lemmas
    emit Invent(to, tokenId, _lemma, number);
    emit Definition(to, tokenId, _definition);
    emit Example(to, tokenId, _example);
  }

  /// @notice Airdrop a new token to an address
  /// @param to The address to airdrop the new token to
  /// @param _lemma The lemma to mint
  /// @param _definition The definition for the lemma
  /// @param _example The example for the lemma
  /// @return tokenId of the minted ERC721 token
  /// @dev Used to migrating v1 tokens to their owners in the v2 lexiconomy. Only the owner can airdrop tokens.
  function airdrop(
    address to,
    string calldata _lemma,
    string calldata _definition,
    string calldata _example
  ) external onlyOwner returns (uint256 tokenId) {
    require(
      lemmaValid(_lemma),
      "LemmaToken: lemma is invalid: does it contain invalid characters?"
    );
    tokenId = getTokenId(_lemma);
    // _mint verifies the tokenId doesn't exist
    _mint(to, tokenId, _lemma, _definition, _example);

    return tokenId;
  }

  /// @notice Mint a new token to the sender of the transaction
  /// @param _lemma The lemma to mint
  /// @param _definition The definition for the lemma
  /// @param _example The example for the lemma
  /// @return tokenId of the minted ERC721 token
  /// @dev All non-airdropped tokens are created by this method
  function mint(
    string calldata _lemma,
    string calldata _definition,
    string calldata _example
  ) public payable returns (uint256 tokenId) {
    require(msg.value >= mintFee(), "LemmaToken: minting fee too low");
    require(
      lemmaValid(_lemma),
      "LemmaToken: lemma is invalid: does it contain invalid characters?"
    );
    tokenId = getTokenId(_lemma);
    // _mint verifies the tokenId doesn't exist
    _mint(msg.sender, tokenId, _lemma, _definition, _example);

    return tokenId;
  }

  /// @notice Add a definition to an existing lemma
  /// @param tokenId The token to define
  /// @param _text The definition text
  /// @dev named 'definition' because 'define' is a reserved keyword
  function definition(uint256 tokenId, string calldata _text)
    public
    whenNotPaused
  {
    // this also prevents defining undefined lemmas
    bool allowed = _isApprovedOrOwner(msg.sender, tokenId);
    require(allowed, "LemmaToken: caller is not owner nor approved");

    lemmas[tokenId].definition = _text;
    emit Definition(msg.sender, tokenId, _text);
  }

  /// @notice Add an example to an existing lemma
  /// @param tokenId The token to define
  /// @param _text The example text
  function example(uint256 tokenId, string calldata _text)
    public
    whenNotPaused
  {
    // this also prevents adding examples for undefined lemmas
    bool allowed = _isApprovedOrOwner(msg.sender, tokenId);
    require(allowed, "LemmaToken: caller is not owner nor approved");

    lemmas[tokenId].example = _text;
    emit Example(msg.sender, tokenId, _text);
  }
}
