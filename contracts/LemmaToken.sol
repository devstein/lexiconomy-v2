//SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol";

import "./Pricer.sol";
import "./StringValidator.sol";
import "./OpenSea.sol";

contract LemmaToken is
  ERC721,
  ERC721Enumerable,
  ERC721URIStorage,
  Pausable,
  Ownable
{
  using ERC165Checker for address;

  // BEGIN: Generated by OpenZepplin
  constructor() ERC721("The Lexiconomy v2", "LEX") {}

  function pause() public onlyOwner {
    _pause();
  }

  function unpause() public onlyOwner {
    _unpause();
  }

  function _baseURI() internal pure override returns (string memory) {
    // tokenURI concats the baseURI with the token id
    // TODO: return "https://lexiconomy.org/token/";
    return "https://lexiconomy-v2.vercel.app/token/";
  }

  function contractURI() public view returns (string memory) {
    // TODO: return "https://lexiconomy.org/cotnract/metadata";
    return "https://lexiconomy-v2.vercel.app/contract/metadata";
  }

  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 tokenId
  ) internal override(ERC721, ERC721Enumerable) whenNotPaused {
    super._beforeTokenTransfer(from, to, tokenId);
  }

  function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
    super._burn(tokenId);
  }

  function tokenURI(uint256 tokenId)
    public
    view
    override(ERC721, ERC721URIStorage)
    returns (string memory)
  {
    return super.tokenURI(tokenId);
  }

  function supportsInterface(bytes4 interfaceId)
    public
    view
    override(ERC721, ERC721Enumerable)
    returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }

  // END: Generated by OpenZepplin

  // BEGIN: Support OpenSea Trading
  address public proxyRegistryAddress;

  function isApprovedForAll(address owner, address operator)
    public
    view
    override
    returns (bool)
  {
    // only execute if proxyRegistryAddress is set
    if (proxyRegistryAddress != address(0)) {
      // Whitelist OpenSea proxy contract for easy trading
      ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);
      if (address(proxyRegistry.proxies(owner)) == operator) {
        return true;
      }
    }

    return super.isApprovedForAll(owner, operator);
  }

  function setProxyRegistryAddress(address _address) public onlyOwner {
    proxyRegistryAddress = _address;
  }

  // END: Support OpenSea Trading

  /// @dev The Invent event is fired whenever a new lemma is invented
  event Invent(address indexed owner, uint256 indexed tokenId, string lemma);

  /// @dev Definition event whenever an owner redefines their lemma
  event Definition(
    address indexed owner,
    uint256 indexed tokenId,
    string definition
  );

  /// @dev Example event whenever an owner provides an example for their lemma
  event Example(address indexed owner, uint256 indexed tokenId, string example);

  struct Lemma {
    string lemma;
    string definition;
    string example;
    // number is a monotonically increasing value for every lemma
    uint256 number;
  }

  mapping(uint256 => Lemma) public lemmas;

  bytes4 public constant pricerInterfaceId = type(Pricer).interfaceId;
  Pricer public pricer;

  function setPricer(address _address) public onlyOwner {
    require(
      _address.supportsInterface(pricerInterfaceId),
      "LemmaToken: address does not implement the Pricer interface"
    );

    Pricer candidateContract = Pricer(_address);

    // Set the new contract address
    pricer = candidateContract;
  }

  bytes4 public constant stringValidatorInterfaceId =
    type(StringValidator).interfaceId;
  StringValidator public lemmaValidator;

  function setLemmaValidator(address _address) public onlyOwner {
    require(
      _address.supportsInterface(stringValidatorInterfaceId),
      "LemmaToken: address does not implement the StringValidator interface"
    );

    StringValidator candidateContract = StringValidator(_address);

    // Set the new contract address
    lemmaValidator = candidateContract;
  }

  function mintFee() public view returns (uint256) {
    return pricer.price();
  }

  function lemmaValid(string calldata _lemma) public view returns (bool) {
    return lemmaValidator.valid(_lemma);
  }

  function getTokenId(string calldata _lemma) public pure returns (uint256) {
    return uint256(keccak256(bytes(_lemma)));
  }

  function _mint(
    address to,
    uint256 tokenId,
    string calldata _lemma,
    string calldata _definition,
    string calldata _example
  ) internal {
    // _safeMint verifies the tokenId doesn't exist
    _safeMint(to, tokenId);
    lemmas[tokenId] = Lemma(_lemma, _definition, _example, totalSupply());

    // emit Invent to let us easily query all created lemmas
    emit Invent(to, tokenId, _lemma);
    emit Definition(to, tokenId, _definition);
    emit Example(to, tokenId, _example);
  }

  // airdrop for migrating v1 tokens to v2
  function airdrop(
    address to,
    string calldata _lemma,
    string calldata _definition,
    string calldata _example
  ) external onlyOwner returns (uint256 tokenId) {
    require(
      lemmaValid(_lemma),
      "LemmaToken: lemma is invalid: does it contain invalid characters?"
    );
    tokenId = getTokenId(_lemma);
    // _mint verifies the tokenId doesn't exist
    _mint(to, tokenId, _lemma, _definition, _example);

    return tokenId;
  }

  function mint(
    string calldata _lemma,
    string calldata _definition,
    string calldata _example
  ) public payable returns (uint256 tokenId) {
    require(msg.value >= mintFee(), "LemmaToken: minting fee too low");
    require(
      lemmaValid(_lemma),
      "LemmaToken: lemma is invalid: does it contain invalid characters?"
    );
    tokenId = getTokenId(_lemma);
    // _mint verifies the tokenId doesn't exist
    _mint(msg.sender, tokenId, _lemma, _definition, _example);

    return tokenId;
  }

  /// @dev named 'definition' because 'define' is a reserved keyword
  function definition(uint256 tokenId, string calldata _text)
    public
    whenNotPaused
  {
    bool allowed = _isApprovedOrOwner(msg.sender, tokenId);
    require(allowed, "LemmaToken: caller is not owner nor approved");

    lemmas[tokenId].definition = _text;
    emit Definition(msg.sender, tokenId, _text);
  }

  function example(uint256 tokenId, string calldata _text)
    public
    whenNotPaused
  {
    bool allowed = _isApprovedOrOwner(msg.sender, tokenId);
    require(allowed, "LemmaToken: caller is not owner nor approved");

    lemmas[tokenId].example = _text;
    emit Example(msg.sender, tokenId, _text);
  }
}
